/**
 * Generated by scripts/browserify/index.js
 * Options:
 *     module: "async-lock"
 *     entry: "AsyncLock"
 *     gadget: { "name": "libAsyncLock", "fileName": "MediaWiki:Gadget-libAsyncLock.js" }
 */
!function() {
    var _$browser_4, cachedSetTimeout, cachedClearTimeout, process = _$browser_4 = {};
    function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
    }
    try {
        cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return (cachedSetTimeout = setTimeout)(fun, 0);
        try {
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    var currentQueue, queue = [], draining = !1, queueIndex = -1;
    function cleanUpNextTick() {
        draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length) && drainQueue();
    }
    function drainQueue() {
        if (!draining) {
            for (var timeout = runTimeout(cleanUpNextTick), len = (draining = !0, queue.length); len; ) {
                for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                queueIndex = -1, len = queue.length;
            }
            currentQueue = null, draining = !1, !function(marker) {
                if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return (cachedClearTimeout = clearTimeout)(marker);
                try {
                    cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }(timeout);
        }
    }
    function Item(fun, array) {
        this.fun = fun, this.array = array;
    }
    function noop() {}
    process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (1 < arguments.length) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
        queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
    }, Item.prototype.run = function() {
        this.fun.apply(null, this.array);
    }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, process.listeners = function(name) {
        return [];
    }, process.binding = function(name) {
        throw new Error("process.binding is not supported");
    }, process.cwd = function() {
        return "/";
    }, process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
    }, process.umask = function() {
        return 0;
    };
    var _$AsyncLock_3 = {}, _$asyncLock_2 = (!function(process) {
        !function() {
            "use strict";
            function AsyncLock(opts) {
                if (this.Promise = (opts = opts || {}).Promise || Promise, this.queues = Object.create(null), this.domainReentrant = opts.domainReentrant || !1, this.domainReentrant) {
                    if (void 0 === process || void 0 === process.domain) throw new Error("Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill.");
                    this.domains = Object.create(null);
                }
                this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT, this.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME, this.maxExecutionTime = opts.maxExecutionTime || AsyncLock.DEFAULT_MAX_EXECUTION_TIME, opts.maxPending === 1 / 0 || Number.isInteger(opts.maxPending) && 0 <= opts.maxPending ? this.maxPending = opts.maxPending : this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
            }
            AsyncLock.DEFAULT_TIMEOUT = 0, AsyncLock.DEFAULT_MAX_OCCUPATION_TIME = 0, AsyncLock.DEFAULT_MAX_EXECUTION_TIME = 0, AsyncLock.DEFAULT_MAX_PENDING = 1e3, AsyncLock.prototype.acquire = function(key, fn, cb, opts) {
                if (Array.isArray(key)) return this._acquireBatch(key, fn, cb, opts);
                if ("function" != typeof fn) throw new Error("You must pass a function to execute");
                var deferredResolve = null, deferredReject = null, deferred = null, resolved = ("function" != typeof cb && (opts = cb, cb = null, deferred = new this.Promise(function(resolve, reject) {
                    deferredResolve = resolve, deferredReject = reject;
                })), opts = opts || {}, !1), timer = null, occupationTimer = null, executionTimer = null, self = this, done = function(locked, err, ret) {
                    occupationTimer && (clearTimeout(occupationTimer), occupationTimer = null), executionTimer && (clearTimeout(executionTimer), executionTimer = null), locked && (self.queues[key] && 0 === self.queues[key].length && delete self.queues[key], self.domainReentrant) && delete self.domains[key], resolved || (deferred ? err ? deferredReject(err) : deferredResolve(ret) : "function" == typeof cb && cb(err, ret), resolved = !0), locked && self.queues[key] && 0 < self.queues[key].length && self.queues[key].shift()();
                }, exec = function(locked) {
                    if (resolved) return done(locked);
                    timer && (clearTimeout(timer), timer = null), self.domainReentrant && locked && (self.domains[key] = process.domain);
                    var maxExecutionTime = opts.maxExecutionTime || self.maxExecutionTime;
                    if (maxExecutionTime && (executionTimer = setTimeout(function() {
                        self.queues[key] && done(locked, new Error("Maximum execution time is exceeded " + key));
                    }, maxExecutionTime)), 1 === fn.length) {
                        var called = !1;
                        try {
                            fn(function(err, ret) {
                                called || (called = !0, done(locked, err, ret));
                            });
                        } catch (err) {
                            called || (called = !0, done(locked, err));
                        }
                    } else self._promiseTry(function() {
                        return fn();
                    }).then(function(ret) {
                        done(locked, void 0, ret);
                    }, function(error) {
                        done(locked, error);
                    });
                }, taskFn = (self.domainReentrant && process.domain && (exec = process.domain.bind(exec)), self.queues[key] ? self.domainReentrant && process.domain && process.domain === self.domains[key] ? exec(!1) : self.queues[key].length >= self.maxPending ? done(!1, new Error("Too many pending tasks in queue " + key)) : (taskFn = function() {
                    exec(!0);
                }, opts.skipQueue ? self.queues[key].unshift(taskFn) : self.queues[key].push(taskFn), (taskFn = opts.timeout || self.timeout) && (timer = setTimeout(function() {
                    timer = null, done(!1, new Error("async-lock timed out in queue " + key));
                }, taskFn))) : (self.queues[key] = [], exec(!0)), opts.maxOccupationTime || self.maxOccupationTime);
                return taskFn && (occupationTimer = setTimeout(function() {
                    self.queues[key] && done(!1, new Error("Maximum occupation time is exceeded in queue " + key));
                }, taskFn)), deferred || void 0;
            }, AsyncLock.prototype._acquireBatch = function(keys, fn, cb, opts) {
                "function" != typeof cb && (opts = cb, cb = null);
                var self = this, fnx = keys.reduceRight(function(prev, key) {
                    return function(key, fn) {
                        return function(cb) {
                            self.acquire(key, fn, cb, opts);
                        };
                    }(key, prev);
                }, fn);
                if ("function" != typeof cb) return new this.Promise(function(resolve, reject) {
                    1 === fnx.length ? fnx(function(err, ret) {
                        err ? reject(err) : resolve(ret);
                    }) : resolve(fnx());
                });
                fnx(cb);
            }, AsyncLock.prototype.isBusy = function(key) {
                return key ? !!this.queues[key] : 0 < Object.keys(this.queues).length;
            }, AsyncLock.prototype._promiseTry = function(fn) {
                try {
                    return this.Promise.resolve(fn());
                } catch (e) {
                    return this.Promise.reject(e);
                }
            }, _$AsyncLock_3 = AsyncLock;
        }.call(this);
    }.call(this, _$browser_4), _$AsyncLock_3);
    !function(global) {
        !function() {
            "use strict";
            var obj = (obj = _$asyncLock_2) && obj.__esModule ? obj : {
                default: obj
            };
            global.AsyncLock = obj.default;
        }.call(this);
    }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}();
