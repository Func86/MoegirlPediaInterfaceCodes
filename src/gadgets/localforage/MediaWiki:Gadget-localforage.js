/**
 * Generated by scripts/browserify/index.js
 * Options:
 *     module: "localforage"
 *     entry: "localforage"
 *     file: "src/gadgets/localforage/MediaWiki:Gadget-localforage.js"
 */
!function() {
    var _$localforage_2 = {
        exports: {}
    };
    (function(global) {
        !function() {
            !function(f) {
                "object" == typeof _$localforage_2.exports ? _$localforage_2.exports = f() : "function" == typeof define && define.amd ? define([], f) : ("undefined" != typeof window ? window : void 0 !== global ? global : "undefined" != typeof self ? self : this).localforage = f();
            }(function() {
                return function e(t, n, r) {
                    function s(o, u) {
                        if (!n[o]) {
                            if (!t[o]) {
                                var a = require;
                                if (!u && a) return a(o, !0);
                                if (i) return i(o, !0);
                                u = new Error("Cannot find module '" + o + "'");
                                throw u.code = "MODULE_NOT_FOUND", u;
                            }
                            a = n[o] = {
                                exports: {}
                            };
                            t[o][0].call(a.exports, function(e) {
                                var n = t[o][1][e];
                                return s(n || e);
                            }, a, a.exports, e, t, n, r);
                        }
                        return n[o].exports;
                    }
                    for (var i = require, o = 0; o < r.length; o++) s(r[o]);
                    return s;
                }({
                    1: [ function(_dereq_, module, exports) {
                        !function(global) {
                            "use strict";
                            var called, element, channel, draining, Mutation = global.MutationObserver || global.WebKitMutationObserver, scheduleDrain = Mutation ? (called = 0, Mutation = new Mutation(nextTick), element = global.document.createTextNode(""), Mutation.observe(element, {
                                characterData: !0
                            }), function() {
                                element.data = called = ++called % 2;
                            }) : global.setImmediate || void 0 === global.MessageChannel ? "document" in global && "onreadystatechange" in global.document.createElement("script") ? function() {
                                var scriptEl = global.document.createElement("script");
                                scriptEl.onreadystatechange = function() {
                                    nextTick(), scriptEl.onreadystatechange = null, scriptEl.parentNode.removeChild(scriptEl), scriptEl = null;
                                }, global.document.documentElement.appendChild(scriptEl);
                            } : function() {
                                setTimeout(nextTick, 0);
                            } : ((channel = new global.MessageChannel()).port1.onmessage = nextTick, function() {
                                channel.port2.postMessage(0);
                            }), queue = [];
                            function nextTick() {
                                draining = !0;
                                for (var i, oldQueue, len = queue.length; len; ) {
                                    for (oldQueue = queue, queue = [], i = -1; ++i < len; ) oldQueue[i]();
                                    len = queue.length;
                                }
                                draining = !1;
                            }
                            module.exports = function(task) {
                                1 !== queue.push(task) || draining || scheduleDrain();
                            };
                        }.call(this, void 0 !== global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                    }, {} ],
                    2: [ function(_dereq_, module, exports) {
                        "use strict";
                        var immediate = _dereq_(1);
                        function INTERNAL() {}
                        var handlers = {}, REJECTED = [ "REJECTED" ], FULFILLED = [ "FULFILLED" ], PENDING = [ "PENDING" ];
                        function Promise(resolver) {
                            if ("function" != typeof resolver) throw new TypeError("resolver must be a function");
                            this.state = PENDING, this.queue = [], this.outcome = void 0, resolver !== INTERNAL && safelyResolveThenable(this, resolver);
                        }
                        function QueueItem(promise, onFulfilled, onRejected) {
                            this.promise = promise, "function" == typeof onFulfilled && (this.onFulfilled = onFulfilled, this.callFulfilled = this.otherCallFulfilled), "function" == typeof onRejected && (this.onRejected = onRejected, this.callRejected = this.otherCallRejected);
                        }
                        function unwrap(promise, func, value) {
                            immediate(function() {
                                var returnValue;
                                try {
                                    returnValue = func(value);
                                } catch (e) {
                                    return handlers.reject(promise, e);
                                }
                                returnValue === promise ? handlers.reject(promise, new TypeError("Cannot resolve promise with itself")) : handlers.resolve(promise, returnValue);
                            });
                        }
                        function getThen(obj) {
                            var then = obj && obj.then;
                            if (obj && ("object" == typeof obj || "function" == typeof obj) && "function" == typeof then) return function() {
                                then.apply(obj, arguments);
                            };
                        }
                        function safelyResolveThenable(self, thenable) {
                            var called = !1;
                            function onError(value) {
                                called || (called = !0, handlers.reject(self, value));
                            }
                            function onSuccess(value) {
                                called || (called = !0, handlers.resolve(self, value));
                            }
                            var result = tryCatch(function() {
                                thenable(onSuccess, onError);
                            });
                            "error" === result.status && onError(result.value);
                        }
                        function tryCatch(func, value) {
                            var out = {};
                            try {
                                out.value = func(value), out.status = "success";
                            } catch (e) {
                                out.status = "error", out.value = e;
                            }
                            return out;
                        }
                        (module.exports = Promise).prototype.catch = function(onRejected) {
                            return this.then(null, onRejected);
                        }, Promise.prototype.then = function(onFulfilled, onRejected) {
                            var promise;
                            return "function" != typeof onFulfilled && this.state === FULFILLED || "function" != typeof onRejected && this.state === REJECTED ? this : (promise = new this.constructor(INTERNAL), this.state !== PENDING ? unwrap(promise, this.state === FULFILLED ? onFulfilled : onRejected, this.outcome) : this.queue.push(new QueueItem(promise, onFulfilled, onRejected)), promise);
                        }, QueueItem.prototype.callFulfilled = function(value) {
                            handlers.resolve(this.promise, value);
                        }, QueueItem.prototype.otherCallFulfilled = function(value) {
                            unwrap(this.promise, this.onFulfilled, value);
                        }, QueueItem.prototype.callRejected = function(value) {
                            handlers.reject(this.promise, value);
                        }, QueueItem.prototype.otherCallRejected = function(value) {
                            unwrap(this.promise, this.onRejected, value);
                        }, handlers.resolve = function(self, value) {
                            var result = tryCatch(getThen, value);
                            if ("error" === result.status) return handlers.reject(self, result.value);
                            result = result.value;
                            if (result) safelyResolveThenable(self, result); else {
                                self.state = FULFILLED, self.outcome = value;
                                for (var i = -1, len = self.queue.length; ++i < len; ) self.queue[i].callFulfilled(value);
                            }
                            return self;
                        }, handlers.reject = function(self, error) {
                            self.state = REJECTED, self.outcome = error;
                            for (var i = -1, len = self.queue.length; ++i < len; ) self.queue[i].callRejected(error);
                            return self;
                        }, Promise.resolve = function(value) {
                            if (value instanceof this) return value;
                            return handlers.resolve(new this(INTERNAL), value);
                        }, Promise.reject = function(reason) {
                            var promise = new this(INTERNAL);
                            return handlers.reject(promise, reason);
                        }, Promise.all = function(iterable) {
                            var self = this;
                            if ("[object Array]" !== Object.prototype.toString.call(iterable)) return this.reject(new TypeError("must be an array"));
                            var len = iterable.length, called = !1;
                            if (!len) return this.resolve([]);
                            var values = new Array(len), resolved = 0, i = -1, promise = new this(INTERNAL);
                            for (;++i < len; ) !function(value, i) {
                                self.resolve(value).then(function(outValue) {
                                    values[i] = outValue, ++resolved !== len || called || (called = !0, handlers.resolve(promise, values));
                                }, function(error) {
                                    called || (called = !0, handlers.reject(promise, error));
                                });
                            }(iterable[i], i);
                            return promise;
                        }, Promise.race = function(iterable) {
                            var self = this;
                            if ("[object Array]" !== Object.prototype.toString.call(iterable)) return this.reject(new TypeError("must be an array"));
                            var len = iterable.length, called = !1;
                            if (!len) return this.resolve([]);
                            var i = -1, promise = new this(INTERNAL);
                            for (;++i < len; ) !function(value) {
                                self.resolve(value).then(function(response) {
                                    called || (called = !0, handlers.resolve(promise, response));
                                }, function(error) {
                                    called || (called = !0, handlers.reject(promise, error));
                                });
                            }(iterable[i]);
                            return promise;
                        };
                    }, {
                        1: 1
                    } ],
                    3: [ function(_dereq_, module, exports) {
                        !function(global) {
                            "use strict";
                            "function" != typeof global.Promise && (global.Promise = _dereq_(2));
                        }.call(this, void 0 !== global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                    }, {
                        2: 2
                    } ],
                    4: [ function(_dereq_, module, exports) {
                        "use strict";
                        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                            return typeof obj;
                        } : function(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                        var idb = function() {
                            try {
                                return "undefined" != typeof indexedDB ? indexedDB : "undefined" != typeof webkitIndexedDB ? webkitIndexedDB : "undefined" != typeof mozIndexedDB ? mozIndexedDB : "undefined" != typeof OIndexedDB ? OIndexedDB : "undefined" != typeof msIndexedDB ? msIndexedDB : void 0;
                            } catch (e) {}
                        }();
                        function createBlob(parts, properties) {
                            parts = parts || [], properties = properties || {};
                            try {
                                return new Blob(parts, properties);
                            } catch (e) {
                                if ("TypeError" !== e.name) throw e;
                                for (var builder = new ("undefined" != typeof BlobBuilder ? BlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder)(), i = 0; i < parts.length; i += 1) builder.append(parts[i]);
                                return builder.getBlob(properties.type);
                            }
                        }
                        "undefined" == typeof Promise && _dereq_(3);
                        var Promise$1 = Promise;
                        function executeCallback(promise, callback) {
                            callback && promise.then(function(result) {
                                callback(null, result);
                            }, function(error) {
                                callback(error);
                            });
                        }
                        function executeTwoCallbacks(promise, callback, errorCallback) {
                            "function" == typeof callback && promise.then(callback), "function" == typeof errorCallback && promise.catch(errorCallback);
                        }
                        function normalizeKey(key) {
                            return "string" != typeof key && (console.warn(key + " used as a key, but it is not a string."), key = String(key)), key;
                        }
                        function getCallback() {
                            if (arguments.length && "function" == typeof arguments[arguments.length - 1]) return arguments[arguments.length - 1];
                        }
                        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support", supportsBlobs = void 0, dbContexts = {}, toString = Object.prototype.toString, READ_WRITE = "readwrite";
                        function _checkBlobSupport(idb) {
                            return "boolean" == typeof supportsBlobs ? Promise$1.resolve(supportsBlobs) : function(idb) {
                                return new Promise$1(function(resolve) {
                                    var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE), blob = createBlob([ "" ]);
                                    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key"), txn.onabort = function(e) {
                                        e.preventDefault(), e.stopPropagation(), resolve(!1);
                                    }, txn.oncomplete = function() {
                                        var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/), matchedEdge = navigator.userAgent.match(/Edge\//);
                                        resolve(matchedEdge || !matchedChrome || 43 <= parseInt(matchedChrome[1], 10));
                                    };
                                }).catch(function() {
                                    return !1;
                                });
                            }(idb).then(function(value) {
                                return supportsBlobs = value;
                            });
                        }
                        function _deferReadiness(dbInfo) {
                            var dbInfo = dbContexts[dbInfo.name], deferredOperation = {};
                            deferredOperation.promise = new Promise$1(function(resolve, reject) {
                                deferredOperation.resolve = resolve, deferredOperation.reject = reject;
                            }), dbInfo.deferredOperations.push(deferredOperation), dbInfo.dbReady ? dbInfo.dbReady = dbInfo.dbReady.then(function() {
                                return deferredOperation.promise;
                            }) : dbInfo.dbReady = deferredOperation.promise;
                        }
                        function _advanceReadiness(dbInfo) {
                            dbInfo = dbContexts[dbInfo.name].deferredOperations.pop();
                            dbInfo && (dbInfo.resolve(), dbInfo.promise);
                        }
                        function _rejectReadiness(dbInfo, err) {
                            dbInfo = dbContexts[dbInfo.name].deferredOperations.pop();
                            if (dbInfo) return dbInfo.reject(err), dbInfo.promise;
                        }
                        function _getConnection(dbInfo, upgradeNeeded) {
                            return new Promise$1(function(resolve, reject) {
                                if (dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext(), dbInfo.db) {
                                    if (!upgradeNeeded) return resolve(dbInfo.db);
                                    _deferReadiness(dbInfo), dbInfo.db.close();
                                }
                                var dbArgs = [ dbInfo.name ], openreq = (upgradeNeeded && dbArgs.push(dbInfo.version), idb.open.apply(idb, dbArgs));
                                upgradeNeeded && (openreq.onupgradeneeded = function(e) {
                                    var db = openreq.result;
                                    try {
                                        db.createObjectStore(dbInfo.storeName), e.oldVersion <= 1 && db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                                    } catch (ex) {
                                        if ("ConstraintError" !== ex.name) throw ex;
                                        console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                                    }
                                }), openreq.onerror = function(e) {
                                    e.preventDefault(), reject(openreq.error);
                                }, openreq.onsuccess = function() {
                                    var db = openreq.result;
                                    db.onversionchange = function(e) {
                                        e.target.close();
                                    }, resolve(db), _advanceReadiness(dbInfo);
                                };
                            });
                        }
                        function _getOriginalConnection(dbInfo) {
                            return _getConnection(dbInfo, !1);
                        }
                        function _getUpgradedConnection(dbInfo) {
                            return _getConnection(dbInfo, !0);
                        }
                        function _isUpgradeNeeded(dbInfo, defaultVersion) {
                            var isNewStore, isUpgrade, isDowngrade;
                            return !dbInfo.db || (isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName), isDowngrade = dbInfo.version < dbInfo.db.version, isUpgrade = dbInfo.version > dbInfo.db.version, isDowngrade && (dbInfo.version !== defaultVersion && console.warn('The database "' + dbInfo.name + "\" can't be downgraded from version " + dbInfo.db.version + " to version " + dbInfo.version + "."), dbInfo.version = dbInfo.db.version), (isUpgrade || isNewStore) && (isNewStore && (isDowngrade = dbInfo.db.version + 1) > dbInfo.version && (dbInfo.version = isDowngrade), 1));
                        }
                        function _decodeBlob(encodedBlob) {
                            return createBlob([ function(bin) {
                                for (var length = bin.length, buf = new ArrayBuffer(length), arr = new Uint8Array(buf), i = 0; i < length; i++) arr[i] = bin.charCodeAt(i);
                                return buf;
                            }(atob(encodedBlob.data)) ], {
                                type: encodedBlob.type
                            });
                        }
                        function _isEncodedBlob(value) {
                            return value && value.__local_forage_encoded_blob;
                        }
                        function _fullyReady(callback) {
                            var self = this, promise = self._initReady().then(function() {
                                var dbContext = dbContexts[self._dbInfo.name];
                                if (dbContext && dbContext.dbReady) return dbContext.dbReady;
                            });
                            return executeTwoCallbacks(promise, callback, callback), promise;
                        }
                        function createTransaction(dbInfo, mode, callback, retries) {
                            void 0 === retries && (retries = 1);
                            try {
                                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                                callback(null, tx);
                            } catch (err) {
                                if (0 < retries && (!dbInfo.db || "InvalidStateError" === err.name || "NotFoundError" === err.name)) return Promise$1.resolve().then(function() {
                                    if (!dbInfo.db || "NotFoundError" === err.name && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) return dbInfo.db && (dbInfo.version = dbInfo.db.version + 1), _getUpgradedConnection(dbInfo);
                                }).then(function() {
                                    return function(dbInfo) {
                                        _deferReadiness(dbInfo);
                                        for (var dbContext = dbContexts[dbInfo.name], forages = dbContext.forages, i = 0; i < forages.length; i++) {
                                            var forage = forages[i];
                                            forage._dbInfo.db && (forage._dbInfo.db.close(), forage._dbInfo.db = null);
                                        }
                                        return dbInfo.db = null, _getOriginalConnection(dbInfo).then(function(db) {
                                            return dbInfo.db = db, _isUpgradeNeeded(dbInfo) ? _getUpgradedConnection(dbInfo) : db;
                                        }).then(function(db) {
                                            dbInfo.db = dbContext.db = db;
                                            for (var i = 0; i < forages.length; i++) forages[i]._dbInfo.db = db;
                                        }).catch(function(err) {
                                            throw _rejectReadiness(dbInfo, err), err;
                                        });
                                    }(dbInfo).then(function() {
                                        createTransaction(dbInfo, mode, callback, retries - 1);
                                    });
                                }).catch(callback);
                                callback(err);
                            }
                        }
                        function createDbContext() {
                            return {
                                forages: [],
                                db: null,
                                dbReady: null,
                                deferredOperations: []
                            };
                        }
                        _dereq_ = {
                            _driver: "asyncStorage",
                            _initStorage: function(options) {
                                var self = this, dbInfo = {
                                    db: null
                                };
                                if (options) for (var i in options) dbInfo[i] = options[i];
                                var dbContext = dbContexts[dbInfo.name], initPromises = (dbContext || (dbContext = createDbContext(), dbContexts[dbInfo.name] = dbContext), dbContext.forages.push(self), self._initReady || (self._initReady = self.ready, self.ready = _fullyReady), []);
                                function ignoreErrors() {
                                    return Promise$1.resolve();
                                }
                                for (var j = 0; j < dbContext.forages.length; j++) {
                                    var forage = dbContext.forages[j];
                                    forage !== self && initPromises.push(forage._initReady().catch(ignoreErrors));
                                }
                                var forages = dbContext.forages.slice(0);
                                return Promise$1.all(initPromises).then(function() {
                                    return dbInfo.db = dbContext.db, _getOriginalConnection(dbInfo);
                                }).then(function(db) {
                                    return dbInfo.db = db, _isUpgradeNeeded(dbInfo, self._defaultConfig.version) ? _getUpgradedConnection(dbInfo) : db;
                                }).then(function(db) {
                                    dbInfo.db = dbContext.db = db, self._dbInfo = dbInfo;
                                    for (var k = 0; k < forages.length; k++) {
                                        var forage = forages[k];
                                        forage !== self && (forage._dbInfo.db = dbInfo.db, forage._dbInfo.version = dbInfo.version);
                                    }
                                });
                            },
                            _support: function() {
                                try {
                                    var isSafari, hasFetch;
                                    return idb && idb.open ? (isSafari = "undefined" != typeof openDatabase && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), hasFetch = "function" == typeof fetch && -1 !== fetch.toString().indexOf("[native code"), (!isSafari || hasFetch) && "undefined" != typeof indexedDB && "undefined" != typeof IDBKeyRange) : !1;
                                } catch (e) {
                                    return !1;
                                }
                            }(),
                            iterate: function(iterator, callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        createTransaction(self._dbInfo, "readonly", function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var req = transaction.objectStore(self._dbInfo.storeName).openCursor(), iterationNumber = 1;
                                                req.onsuccess = function() {
                                                    var value, cursor = req.result;
                                                    cursor ? (_isEncodedBlob(value = cursor.value) && (value = _decodeBlob(value)), void 0 !== (value = iterator(value, cursor.key, iterationNumber++)) ? resolve(value) : cursor.continue()) : resolve();
                                                }, req.onerror = function() {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            getItem: function(key, callback) {
                                var self = this, promise = (key = normalizeKey(key), new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        createTransaction(self._dbInfo, "readonly", function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var req = transaction.objectStore(self._dbInfo.storeName).get(key);
                                                req.onsuccess = function() {
                                                    var value = req.result;
                                                    _isEncodedBlob(value = void 0 === value ? null : value) && (value = _decodeBlob(value)), resolve(value);
                                                }, req.onerror = function() {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            setItem: function(key, value, callback) {
                                var self = this, promise = (key = normalizeKey(key), new Promise$1(function(resolve, reject) {
                                    var dbInfo;
                                    self.ready().then(function() {
                                        return dbInfo = self._dbInfo, "[object Blob]" === toString.call(value) ? _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                                            return blobSupport ? value : (blob = value, new Promise$1(function(resolve, reject) {
                                                var reader = new FileReader();
                                                reader.onerror = reject, reader.onloadend = function(e) {
                                                    e = btoa(e.target.result || "");
                                                    resolve({
                                                        __local_forage_encoded_blob: !0,
                                                        data: e,
                                                        type: blob.type
                                                    });
                                                }, reader.readAsBinaryString(blob);
                                            }));
                                            var blob;
                                        }) : value;
                                    }).then(function(value) {
                                        createTransaction(self._dbInfo, READ_WRITE, function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName), req = (null === value && (value = void 0), store.put(value, key));
                                                transaction.oncomplete = function() {
                                                    resolve(value = void 0 === value ? null : value);
                                                }, transaction.onabort = transaction.onerror = function() {
                                                    var err = req.error || req.transaction.error;
                                                    reject(err);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            removeItem: function(key, callback) {
                                var self = this, promise = (key = normalizeKey(key), new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        createTransaction(self._dbInfo, READ_WRITE, function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var req = transaction.objectStore(self._dbInfo.storeName).delete(key);
                                                transaction.oncomplete = function() {
                                                    resolve();
                                                }, transaction.onerror = function() {
                                                    reject(req.error);
                                                }, transaction.onabort = function() {
                                                    var err = req.error || req.transaction.error;
                                                    reject(err);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            clear: function(callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        createTransaction(self._dbInfo, READ_WRITE, function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var req = transaction.objectStore(self._dbInfo.storeName).clear();
                                                transaction.oncomplete = function() {
                                                    resolve();
                                                }, transaction.onabort = transaction.onerror = function() {
                                                    var err = req.error || req.transaction.error;
                                                    reject(err);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            length: function(callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        createTransaction(self._dbInfo, "readonly", function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var req = transaction.objectStore(self._dbInfo.storeName).count();
                                                req.onsuccess = function() {
                                                    resolve(req.result);
                                                }, req.onerror = function() {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            key: function(n, callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    n < 0 ? resolve(null) : self.ready().then(function() {
                                        createTransaction(self._dbInfo, "readonly", function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName), advanced = !1, req = store.openKeyCursor();
                                                req.onsuccess = function() {
                                                    var cursor = req.result;
                                                    cursor ? 0 === n || advanced ? resolve(cursor.key) : (advanced = !0, cursor.advance(n)) : resolve(null);
                                                }, req.onerror = function() {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            keys: function(callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        createTransaction(self._dbInfo, "readonly", function(err, transaction) {
                                            if (err) return reject(err);
                                            try {
                                                var req = transaction.objectStore(self._dbInfo.storeName).openKeyCursor(), keys = [];
                                                req.onsuccess = function() {
                                                    var cursor = req.result;
                                                    cursor ? (keys.push(cursor.key), cursor.continue()) : resolve(keys);
                                                }, req.onerror = function() {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            dropInstance: function(options, callback) {
                                callback = getCallback.apply(this, arguments);
                                var currentConfig = this.config();
                                return (options = "function" != typeof options && options || {}).name || (options.name = options.name || currentConfig.name, options.storeName = options.storeName || currentConfig.storeName), executeCallback(currentConfig = options.name ? (currentConfig = options.name === currentConfig.name && this._dbInfo.db ? Promise$1.resolve(this._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
                                    var dbContext = dbContexts[options.name], forages = dbContext.forages;
                                    dbContext.db = db;
                                    for (var i = 0; i < forages.length; i++) forages[i]._dbInfo.db = db;
                                    return db;
                                }), options.storeName ? currentConfig.then(function(db) {
                                    if (db.objectStoreNames.contains(options.storeName)) {
                                        var newVersion = db.version + 1, dbContext = (_deferReadiness(options), dbContexts[options.name]), forages = dbContext.forages;
                                        db.close();
                                        for (var i = 0; i < forages.length; i++) {
                                            var forage = forages[i];
                                            forage._dbInfo.db = null, forage._dbInfo.version = newVersion;
                                        }
                                        return new Promise$1(function(resolve, reject) {
                                            var req = idb.open(options.name, newVersion);
                                            req.onerror = function(err) {
                                                req.result.close(), reject(err);
                                            }, req.onupgradeneeded = function() {
                                                req.result.deleteObjectStore(options.storeName);
                                            }, req.onsuccess = function() {
                                                var db = req.result;
                                                db.close(), resolve(db);
                                            };
                                        }).then(function(db) {
                                            dbContext.db = db;
                                            for (var j = 0; j < forages.length; j++) {
                                                var _forage2 = forages[j];
                                                _forage2._dbInfo.db = db, _advanceReadiness(_forage2._dbInfo);
                                            }
                                        }).catch(function(err) {
                                            throw (_rejectReadiness(options, err) || Promise$1.resolve()).catch(function() {}), err;
                                        });
                                    }
                                }) : currentConfig.then(function(db) {
                                    _deferReadiness(options);
                                    var dbContext = dbContexts[options.name], forages = dbContext.forages;
                                    db.close();
                                    for (var i = 0; i < forages.length; i++) forages[i]._dbInfo.db = null;
                                    return new Promise$1(function(resolve, reject) {
                                        var req = idb.deleteDatabase(options.name);
                                        req.onerror = function() {
                                            var db = req.result;
                                            db && db.close(), reject(req.error);
                                        }, req.onblocked = function() {
                                            console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                                        }, req.onsuccess = function() {
                                            var db = req.result;
                                            db && db.close(), resolve(db);
                                        };
                                    }).then(function(db) {
                                        dbContext.db = db;
                                        for (var i = 0; i < forages.length; i++) _advanceReadiness(forages[i]._dbInfo);
                                    }).catch(function(err) {
                                        throw (_rejectReadiness(options, err) || Promise$1.resolve()).catch(function() {}), err;
                                    });
                                })) : Promise$1.reject("Invalid arguments"), callback), currentConfig;
                            }
                        };
                        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/, SERIALIZED_MARKER_LENGTH = "__lfsc__:".length, TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + "arbf".length, toString$1 = Object.prototype.toString;
                        function stringToBuffer(serializedString) {
                            for (var encoded1, encoded2, encoded3, encoded4, bufferLength = .75 * serializedString.length, len = serializedString.length, p = 0, bufferLength = ("=" === serializedString[serializedString.length - 1] && (bufferLength--, "=" === serializedString[serializedString.length - 2]) && bufferLength--, new ArrayBuffer(bufferLength)), bytes = new Uint8Array(bufferLength), i = 0; i < len; i += 4) encoded1 = BASE_CHARS.indexOf(serializedString[i]), encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]), encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]), encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]), bytes[p++] = encoded1 << 2 | encoded2 >> 4, bytes[p++] = (15 & encoded2) << 4 | encoded3 >> 2, bytes[p++] = (3 & encoded3) << 6 | 63 & encoded4;
                            return bufferLength;
                        }
                        function bufferToString(buffer) {
                            for (var bytes = new Uint8Array(buffer), base64String = "", i = 0; i < bytes.length; i += 3) base64String = (base64String = (base64String = (base64String += BASE_CHARS[bytes[i] >> 2]) + BASE_CHARS[(3 & bytes[i]) << 4 | bytes[i + 1] >> 4]) + BASE_CHARS[(15 & bytes[i + 1]) << 2 | bytes[i + 2] >> 6]) + BASE_CHARS[63 & bytes[i + 2]];
                            return bytes.length % 3 == 2 ? base64String = base64String.substring(0, base64String.length - 1) + "=" : bytes.length % 3 == 1 && (base64String = base64String.substring(0, base64String.length - 2) + "=="), base64String;
                        }
                        var localforageSerializer = {
                            serialize: function(value, callback) {
                                var valueType = "";
                                if (value && (valueType = toString$1.call(value)), value && ("[object ArrayBuffer]" === valueType || value.buffer && "[object ArrayBuffer]" === toString$1.call(value.buffer))) {
                                    var buffer, marker = "__lfsc__:";
                                    value instanceof ArrayBuffer ? (buffer = value, marker += "arbf") : (buffer = value.buffer, "[object Int8Array]" === valueType ? marker += "si08" : "[object Uint8Array]" === valueType ? marker += "ui08" : "[object Uint8ClampedArray]" === valueType ? marker += "uic8" : "[object Int16Array]" === valueType ? marker += "si16" : "[object Uint16Array]" === valueType ? marker += "ur16" : "[object Int32Array]" === valueType ? marker += "si32" : "[object Uint32Array]" === valueType ? marker += "ui32" : "[object Float32Array]" === valueType ? marker += "fl32" : "[object Float64Array]" === valueType ? marker += "fl64" : callback(new Error("Failed to get type for BinaryArray"))), callback(marker + bufferToString(buffer));
                                } else if ("[object Blob]" === valueType) {
                                    marker = new FileReader();
                                    marker.onload = function() {
                                        var str = "~~local_forage_type~" + value.type + "~" + bufferToString(this.result);
                                        callback("__lfsc__:blob" + str);
                                    }, marker.readAsArrayBuffer(value);
                                } else try {
                                    callback(JSON.stringify(value));
                                } catch (e) {
                                    console.error("Couldn't convert value into a JSON string: ", value), callback(null, e);
                                }
                            },
                            deserialize: function(value) {
                                if ("__lfsc__:" !== value.substring(0, SERIALIZED_MARKER_LENGTH)) return JSON.parse(value);
                                var blobType, serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH), type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH), buffer = ("blob" === type && BLOB_TYPE_PREFIX_REGEX.test(serializedString) && (blobType = (value = serializedString.match(BLOB_TYPE_PREFIX_REGEX))[1], serializedString = serializedString.substring(value[0].length)), stringToBuffer(serializedString));
                                switch (type) {
                                  case "arbf":
                                    return buffer;

                                  case "blob":
                                    return createBlob([ buffer ], {
                                        type: blobType
                                    });

                                  case "si08":
                                    return new Int8Array(buffer);

                                  case "ui08":
                                    return new Uint8Array(buffer);

                                  case "uic8":
                                    return new Uint8ClampedArray(buffer);

                                  case "si16":
                                    return new Int16Array(buffer);

                                  case "ur16":
                                    return new Uint16Array(buffer);

                                  case "si32":
                                    return new Int32Array(buffer);

                                  case "ui32":
                                    return new Uint32Array(buffer);

                                  case "fl32":
                                    return new Float32Array(buffer);

                                  case "fl64":
                                    return new Float64Array(buffer);

                                  default:
                                    throw new Error("Unkown type: " + type);
                                }
                            },
                            stringToBuffer: stringToBuffer,
                            bufferToString: bufferToString
                        };
                        function createDbTable(t, dbInfo, callback, errorCallback) {
                            t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
                        }
                        function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
                            t.executeSql(sqlStatement, args, callback, function(t, error) {
                                error.code === error.SYNTAX_ERR ? t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [ dbInfo.storeName ], function(t, results) {
                                    results.rows.length ? errorCallback(t, error) : createDbTable(t, dbInfo, function() {
                                        t.executeSql(sqlStatement, args, callback, errorCallback);
                                    }, errorCallback);
                                }, errorCallback) : errorCallback(t, error);
                            }, errorCallback);
                        }
                        function _setItem(key, value, callback, retriesLeft) {
                            var self = this, promise = (key = normalizeKey(key), new Promise$1(function(resolve, reject) {
                                self.ready().then(function() {
                                    var originalValue = value = void 0 === value ? null : value, dbInfo = self._dbInfo;
                                    dbInfo.serializer.serialize(value, function(value, error) {
                                        error ? reject(error) : dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [ key, value ], function() {
                                                resolve(originalValue);
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        }, function(sqlError) {
                                            sqlError.code === sqlError.QUOTA_ERR && (0 < retriesLeft ? resolve(_setItem.apply(self, [ key, originalValue, callback, retriesLeft - 1 ])) : reject(sqlError));
                                        });
                                    });
                                }).catch(reject);
                            }));
                            return executeCallback(promise, callback), promise;
                        }
                        var webSQLStorage = {
                            _driver: "webSQLStorage",
                            _initStorage: function(options) {
                                var self = this, dbInfo = {
                                    db: null
                                };
                                if (options) for (var i in options) dbInfo[i] = "string" != typeof options[i] ? options[i].toString() : options[i];
                                var dbInfoPromise = new Promise$1(function(resolve, reject) {
                                    try {
                                        dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
                                    } catch (e) {
                                        return reject(e);
                                    }
                                    dbInfo.db.transaction(function(t) {
                                        createDbTable(t, dbInfo, function() {
                                            self._dbInfo = dbInfo, resolve();
                                        }, function(t, error) {
                                            reject(error);
                                        });
                                    }, reject);
                                });
                                return dbInfo.serializer = localforageSerializer, dbInfoPromise;
                            },
                            _support: "function" == typeof openDatabase,
                            iterate: function(iterator, callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t, results) {
                                                for (var rows = results.rows, length = rows.length, i = 0; i < length; i++) {
                                                    var item = rows.item(i), result = (result = item.value) && dbInfo.serializer.deserialize(result);
                                                    if (void 0 !== (result = iterator(result, item.key, i + 1))) return void resolve(result);
                                                }
                                                resolve();
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            getItem: function(key, callback) {
                                var self = this, promise = (key = normalizeKey(key), new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [ key ], function(t, results) {
                                                results = (results = results.rows.length ? results.rows.item(0).value : null) && dbInfo.serializer.deserialize(results);
                                                resolve(results);
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        });
                                    }).catch(reject);
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            setItem: function(key, value, callback) {
                                return _setItem.apply(this, [ key, value, callback, 1 ]);
                            },
                            removeItem: function(key, callback) {
                                var self = this, promise = (key = normalizeKey(key), new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [ key ], function() {
                                                resolve();
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        });
                                    }).catch(reject);
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            clear: function(callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                                                resolve();
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            length: function(callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t, results) {
                                                results = results.rows.item(0).c;
                                                resolve(results);
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            key: function(n, callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [ n + 1 ], function(t, results) {
                                                results = results.rows.length ? results.rows.item(0).key : null;
                                                resolve(results);
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            keys: function(callback) {
                                var self = this, promise = new Promise$1(function(resolve, reject) {
                                    self.ready().then(function() {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function(t) {
                                            tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t, results) {
                                                for (var keys = [], i = 0; i < results.rows.length; i++) keys.push(results.rows.item(i).key);
                                                resolve(keys);
                                            }, function(t, error) {
                                                reject(error);
                                            });
                                        });
                                    }).catch(reject);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            dropInstance: function(options, callback) {
                                callback = getCallback.apply(this, arguments);
                                var currentConfig = this.config(), self = ((options = "function" != typeof options && options || {}).name || (options.name = options.name || currentConfig.name, options.storeName = options.storeName || currentConfig.storeName), this), promise = options.name ? new Promise$1(function(resolve) {
                                    var db = options.name === currentConfig.name ? self._dbInfo.db : openDatabase(options.name, "", "", 0);
                                    options.storeName ? resolve({
                                        db: db,
                                        storeNames: [ options.storeName ]
                                    }) : resolve(function(db) {
                                        return new Promise$1(function(resolve, reject) {
                                            db.transaction(function(t) {
                                                t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t, results) {
                                                    for (var storeNames = [], i = 0; i < results.rows.length; i++) storeNames.push(results.rows.item(i).name);
                                                    resolve({
                                                        db: db,
                                                        storeNames: storeNames
                                                    });
                                                }, function(t, error) {
                                                    reject(error);
                                                });
                                            }, function(sqlError) {
                                                reject(sqlError);
                                            });
                                        });
                                    }(db));
                                }).then(function(operationInfo) {
                                    return new Promise$1(function(resolve, reject) {
                                        operationInfo.db.transaction(function(t) {
                                            for (var operations = [], i = 0, len = operationInfo.storeNames.length; i < len; i++) operations.push(function(storeName) {
                                                return new Promise$1(function(resolve, reject) {
                                                    t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                                                        resolve();
                                                    }, function(t, error) {
                                                        reject(error);
                                                    });
                                                });
                                            }(operationInfo.storeNames[i]));
                                            Promise$1.all(operations).then(function() {
                                                resolve();
                                            }).catch(function(e) {
                                                reject(e);
                                            });
                                        }, function(sqlError) {
                                            reject(sqlError);
                                        });
                                    });
                                }) : Promise$1.reject("Invalid arguments");
                                return executeCallback(promise, callback), promise;
                            }
                        };
                        function _getKeyPrefix(options, defaultConfig) {
                            var keyPrefix = options.name + "/";
                            return options.storeName !== defaultConfig.storeName && (keyPrefix += options.storeName + "/"), keyPrefix;
                        }
                        function _isLocalStorageUsable() {
                            return !function() {
                                try {
                                    localStorage.setItem("_localforage_support_test", !0), localStorage.removeItem("_localforage_support_test");
                                } catch (e) {
                                    return 1;
                                }
                            }() || 0 < localStorage.length;
                        }
                        function includes(array, searchElement) {
                            for (var x, y, len = array.length, i = 0; i < len; ) {
                                if ((x = array[i]) === (y = searchElement) || "number" == typeof x && "number" == typeof y && isNaN(x) && isNaN(y)) return 1;
                                i++;
                            }
                        }
                        var localStorageWrapper = {
                            _driver: "localStorageWrapper",
                            _initStorage: function(options) {
                                var dbInfo = {};
                                if (options) for (var i in options) dbInfo[i] = options[i];
                                return dbInfo.keyPrefix = _getKeyPrefix(options, this._defaultConfig), _isLocalStorageUsable() ? ((this._dbInfo = dbInfo).serializer = localforageSerializer, Promise$1.resolve()) : Promise$1.reject();
                            },
                            _support: function() {
                                try {
                                    return "undefined" != typeof localStorage && "setItem" in localStorage && !!localStorage.setItem;
                                } catch (e) {
                                    return !1;
                                }
                            }(),
                            iterate: function(iterator, callback) {
                                var self = this, promise = self.ready().then(function() {
                                    for (var dbInfo = self._dbInfo, keyPrefix = dbInfo.keyPrefix, keyPrefixLength = keyPrefix.length, length = localStorage.length, iterationNumber = 1, i = 0; i < length; i++) {
                                        var key = localStorage.key(i);
                                        if (0 === key.indexOf(keyPrefix)) {
                                            var value = (value = localStorage.getItem(key)) && dbInfo.serializer.deserialize(value);
                                            if (void 0 !== (value = iterator(value, key.substring(keyPrefixLength), iterationNumber++))) return value;
                                        }
                                    }
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            getItem: function(key, callback) {
                                var self = this, promise = (key = normalizeKey(key), self.ready().then(function() {
                                    var dbInfo = self._dbInfo, result = localStorage.getItem(dbInfo.keyPrefix + key);
                                    return result = result && dbInfo.serializer.deserialize(result);
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            setItem: function(key, value, callback) {
                                var self = this, promise = (key = normalizeKey(key), self.ready().then(function() {
                                    var originalValue = value = void 0 === value ? null : value;
                                    return new Promise$1(function(resolve, reject) {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.serializer.serialize(value, function(value, error) {
                                            if (error) reject(error); else try {
                                                localStorage.setItem(dbInfo.keyPrefix + key, value), resolve(originalValue);
                                            } catch (e) {
                                                "QuotaExceededError" !== e.name && "NS_ERROR_DOM_QUOTA_REACHED" !== e.name || reject(e), reject(e);
                                            }
                                        });
                                    });
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            removeItem: function(key, callback) {
                                var self = this, promise = (key = normalizeKey(key), self.ready().then(function() {
                                    var dbInfo = self._dbInfo;
                                    localStorage.removeItem(dbInfo.keyPrefix + key);
                                }));
                                return executeCallback(promise, callback), promise;
                            },
                            clear: function(callback) {
                                var self = this, promise = self.ready().then(function() {
                                    for (var keyPrefix = self._dbInfo.keyPrefix, i = localStorage.length - 1; 0 <= i; i--) {
                                        var key = localStorage.key(i);
                                        0 === key.indexOf(keyPrefix) && localStorage.removeItem(key);
                                    }
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            length: function(callback) {
                                var promise = this.keys().then(function(keys) {
                                    return keys.length;
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            key: function(n, callback) {
                                var self = this, promise = self.ready().then(function() {
                                    var result, dbInfo = self._dbInfo;
                                    try {
                                        result = localStorage.key(n);
                                    } catch (error) {
                                        result = null;
                                    }
                                    return result = result && result.substring(dbInfo.keyPrefix.length);
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            keys: function(callback) {
                                var self = this, promise = self.ready().then(function() {
                                    for (var dbInfo = self._dbInfo, length = localStorage.length, keys = [], i = 0; i < length; i++) {
                                        var itemKey = localStorage.key(i);
                                        0 === itemKey.indexOf(dbInfo.keyPrefix) && keys.push(itemKey.substring(dbInfo.keyPrefix.length));
                                    }
                                    return keys;
                                });
                                return executeCallback(promise, callback), promise;
                            },
                            dropInstance: function(options, callback) {
                                callback = getCallback.apply(this, arguments), (options = "function" != typeof options && options || {}).name || (currentConfig = this.config(), options.name = options.name || currentConfig.name, options.storeName = options.storeName || currentConfig.storeName);
                                var self = this, currentConfig = options.name ? new Promise$1(function(resolve) {
                                    options.storeName ? resolve(_getKeyPrefix(options, self._defaultConfig)) : resolve(options.name + "/");
                                }).then(function(keyPrefix) {
                                    for (var i = localStorage.length - 1; 0 <= i; i--) {
                                        var key = localStorage.key(i);
                                        0 === key.indexOf(keyPrefix) && localStorage.removeItem(key);
                                    }
                                }) : Promise$1.reject("Invalid arguments");
                                return executeCallback(currentConfig, callback), currentConfig;
                            }
                        }, isArray = Array.isArray || function(arg) {
                            return "[object Array]" === Object.prototype.toString.call(arg);
                        }, DefinedDrivers = {}, DriverSupport = {}, DefaultDrivers = {
                            INDEXEDDB: _dereq_,
                            WEBSQL: webSQLStorage,
                            LOCALSTORAGE: localStorageWrapper
                        }, _dereq_ = [ DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver ], OptionalDriverMethods = [ "dropInstance" ], LibraryMethods = [ "clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem" ].concat(OptionalDriverMethods), DefaultConfig = {
                            description: "",
                            driver: _dereq_.slice(),
                            name: "localforage",
                            size: 4980736,
                            storeName: "keyvaluepairs",
                            version: 1
                        };
                        function extend(argument_0) {
                            for (var i = 1; i < arguments.length; i++) {
                                var arg = arguments[i];
                                if (arg) for (var _key in arg) arg.hasOwnProperty(_key) && (isArray(arg[_key]) ? argument_0[_key] = arg[_key].slice() : argument_0[_key] = arg[_key]);
                            }
                            return argument_0;
                        }
                        webSQLStorage = new (function() {
                            function LocalForage(options) {
                                var driverTypeKey, driver, driverName;
                                if (!(this instanceof LocalForage)) throw new TypeError("Cannot call a class as a function");
                                for (driverTypeKey in DefaultDrivers) DefaultDrivers.hasOwnProperty(driverTypeKey) && (driverName = (driver = DefaultDrivers[driverTypeKey])._driver, this[driverTypeKey] = driverName, DefinedDrivers[driverName] || this.defineDriver(driver));
                                this._defaultConfig = extend({}, DefaultConfig), this._config = extend({}, this._defaultConfig, options), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {});
                            }
                            return LocalForage.prototype.config = function(options) {
                                if ("object" !== (void 0 === options ? "undefined" : _typeof(options))) return "string" == typeof options ? this._config[options] : this._config;
                                if (this._ready) return new Error("Can't call config() after localforage has been used.");
                                for (var i in options) {
                                    if ("storeName" === i && (options[i] = options[i].replace(/\W/g, "_")), "version" === i && "number" != typeof options[i]) return new Error("Database version must be a number.");
                                    this._config[i] = options[i];
                                }
                                return !("driver" in options && options.driver) || this.setDriver(this._config.driver);
                            }, LocalForage.prototype.defineDriver = function(driverObject, callback, errorCallback) {
                                var promise = new Promise$1(function(resolve, reject) {
                                    try {
                                        var driverName = driverObject._driver, complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                                        if (driverObject._driver) {
                                            for (var driverMethods = LibraryMethods.concat("_initStorage"), i = 0, len = driverMethods.length; i < len; i++) {
                                                var driverMethodName = driverMethods[i];
                                                if ((!includes(OptionalDriverMethods, driverMethodName) || driverObject[driverMethodName]) && "function" != typeof driverObject[driverMethodName]) return void reject(complianceError);
                                            }
                                            !function() {
                                                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                                                    var optionalDriverMethod = OptionalDriverMethods[_i];
                                                    driverObject[optionalDriverMethod] || (driverObject[optionalDriverMethod] = function(methodName) {
                                                        return function() {
                                                            var error = new Error("Method " + methodName + " is not implemented by the current driver"), error = Promise$1.reject(error);
                                                            return executeCallback(error, arguments[arguments.length - 1]), error;
                                                        };
                                                    }(optionalDriverMethod));
                                                }
                                            }();
                                            var setDriverSupport = function(support) {
                                                DefinedDrivers[driverName] && console.info("Redefining LocalForage driver: " + driverName), DefinedDrivers[driverName] = driverObject, DriverSupport[driverName] = support, resolve();
                                            };
                                            "_support" in driverObject ? driverObject._support && "function" == typeof driverObject._support ? driverObject._support().then(setDriverSupport, reject) : setDriverSupport(!!driverObject._support) : setDriverSupport(!0);
                                        } else reject(complianceError);
                                    } catch (e) {
                                        reject(e);
                                    }
                                });
                                return executeTwoCallbacks(promise, callback, errorCallback), promise;
                            }, LocalForage.prototype.driver = function() {
                                return this._driver || null;
                            }, LocalForage.prototype.getDriver = function(driverName, callback, errorCallback) {
                                driverName = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
                                return executeTwoCallbacks(driverName, callback, errorCallback), driverName;
                            }, LocalForage.prototype.getSerializer = function(callback) {
                                var serializerPromise = Promise$1.resolve(localforageSerializer);
                                return executeTwoCallbacks(serializerPromise, callback), serializerPromise;
                            }, LocalForage.prototype.ready = function(callback) {
                                var self = this, promise = self._driverSet.then(function() {
                                    return null === self._ready && (self._ready = self._initDriver()), self._ready;
                                });
                                return executeTwoCallbacks(promise, callback, callback), promise;
                            }, LocalForage.prototype.setDriver = function(drivers, callback, errorCallback) {
                                var self = this, supportedDrivers = (isArray(drivers) || (drivers = [ drivers ]), this._getSupportedDrivers(drivers));
                                function setDriverToConfig() {
                                    self._config.driver = self.driver();
                                }
                                function extendSelfWithDriver(driver) {
                                    return self._extend(driver), setDriverToConfig(), self._ready = self._initStorage(self._config), self._ready;
                                }
                                function initDriver(supportedDrivers) {
                                    return function() {
                                        var currentDriverIndex = 0;
                                        return function driverPromiseLoop() {
                                            for (;currentDriverIndex < supportedDrivers.length; ) {
                                                var driverName = supportedDrivers[currentDriverIndex];
                                                return currentDriverIndex++, self._dbInfo = null, self._ready = null, self.getDriver(driverName).then(extendSelfWithDriver).catch(driverPromiseLoop);
                                            }
                                            setDriverToConfig();
                                            var error = new Error("No available storage method found.");
                                            return self._driverSet = Promise$1.reject(error), self._driverSet;
                                        }();
                                    };
                                }
                                drivers = null !== this._driverSet ? this._driverSet.catch(function() {
                                    return Promise$1.resolve();
                                }) : Promise$1.resolve();
                                return this._driverSet = drivers.then(function() {
                                    var driverName = supportedDrivers[0];
                                    return self._dbInfo = null, self._ready = null, self.getDriver(driverName).then(function(driver) {
                                        self._driver = driver._driver, setDriverToConfig(), self._wrapLibraryMethodsWithReady(), self._initDriver = initDriver(supportedDrivers);
                                    });
                                }).catch(function() {
                                    setDriverToConfig();
                                    var error = new Error("No available storage method found.");
                                    return self._driverSet = Promise$1.reject(error), self._driverSet;
                                }), executeTwoCallbacks(this._driverSet, callback, errorCallback), this._driverSet;
                            }, LocalForage.prototype.supports = function(driverName) {
                                return !!DriverSupport[driverName];
                            }, LocalForage.prototype._extend = function(libraryMethodsAndProperties) {
                                extend(this, libraryMethodsAndProperties);
                            }, LocalForage.prototype._getSupportedDrivers = function(drivers) {
                                for (var supportedDrivers = [], i = 0, len = drivers.length; i < len; i++) {
                                    var driverName = drivers[i];
                                    this.supports(driverName) && supportedDrivers.push(driverName);
                                }
                                return supportedDrivers;
                            }, LocalForage.prototype._wrapLibraryMethodsWithReady = function() {
                                for (var i = 0, len = LibraryMethods.length; i < len; i++) !function(localForageInstance, libraryMethod) {
                                    localForageInstance[libraryMethod] = function() {
                                        var _args = arguments;
                                        return localForageInstance.ready().then(function() {
                                            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
                                        });
                                    };
                                }(this, LibraryMethods[i]);
                            }, LocalForage.prototype.createInstance = function(options) {
                                return new LocalForage(options);
                            }, LocalForage;
                        }())();
                        module.exports = webSQLStorage;
                    }, {
                        3: 3
                    } ]
                }, {}, [ 4 ])(4);
            });
        }.call(this);
    }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}), _$localforage_2 = _$localforage_2.exports;
    !function(global) {
        !function() {
            "use strict";
            var obj = (obj = _$localforage_2) && obj.__esModule ? obj : {
                default: obj
            };
            global.localforage = obj.default;
        }.call(this);
    }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}();
