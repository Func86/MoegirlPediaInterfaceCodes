/**
 * Generated by scripts/browserify/index.js
 * Options:
 *     module: "cron"
 *     entry: "Cron"
 *     gadget: { "name": "cron", "fileName": "MediaWiki:Gadget-cron.js" }
 *     prependCode: "const require = () => window.luxon;"
 */
const require = () => window.luxon;
!function() {
    function createModuleFactory(t) {
        var e;
        return function(r) {
            return e || t(e = {
                exports: {},
                parent: r
            }, e.exports), e.exports;
        };
    }
    var root, factory, _$CronJob_4 = createModuleFactory(function(module, exports) {
        module.exports = function(CronTime, spawn) {
            function fnWrap(cmd) {
                var args, options, command;
                switch (typeof cmd) {
                  case "string":
                    return command = (args = cmd.split(" ")).shift(), spawn.bind(void 0, command, args);

                  case "object":
                    if (command = cmd && cmd.command) return args = cmd.args, options = cmd.options, spawn.bind(void 0, command, args, options);
                }
                return cmd;
            }
            function CJ(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) {
                for (var _cronTime = cronTime, argCount = 0, i = 0; i < arguments.length; i++) void 0 !== arguments[i] && argCount++;
                return "string" != typeof cronTime && 1 === argCount && (onTick = cronTime.onTick, onComplete = cronTime.onComplete, context = cronTime.context, startNow = cronTime.start || cronTime.startNow || cronTime.startJob, timeZone = cronTime.timeZone, runOnInit = cronTime.runOnInit, _cronTime = cronTime.cronTime, utcOffset = cronTime.utcOffset, unrefTimeout = cronTime.unrefTimeout), this.context = context || this, this._callbacks = [], this.onComplete = fnWrap(onComplete), this.cronTime = new CronTime(_cronTime, timeZone, utcOffset), this.unrefTimeout = unrefTimeout, addCallback.call(this, fnWrap(onTick)), runOnInit && (this.lastExecution = new Date(), fireOnTick.call(this)), startNow && start.call(this), this;
            }
            function addCallback(callback) {
                "function" == typeof callback && this._callbacks.push(callback);
            }
            CJ.prototype.addCallback = addCallback, CJ.prototype.setTime = function(time) {
                if ("object" != typeof time) throw new Error("time must be an instance of CronTime.");
                this.stop(), this.cronTime = time, this.start();
            }, CJ.prototype.nextDate = function() {
                return this.cronTime.sendAt();
            };
            var fireOnTick = function() {
                for (var i = this._callbacks.length - 1; 0 <= i; i--) this._callbacks[i].call(this.context, this.onComplete);
            }, start = (CJ.prototype.fireOnTick = fireOnTick, CJ.prototype.nextDates = function(i) {
                return this.cronTime.sendAt(i);
            }, function() {
                var MAXDELAY, self, timeout, remaining, startTime;
                function _setTimeout(timeout) {
                    startTime = Date.now(), self._timeout = setTimeout(callbackWrapper, timeout), self.unrefTimeout && "function" == typeof self._timeout.unref && self._timeout.unref();
                }
                function callbackWrapper() {
                    var newTimeout, diff = startTime + timeout - Date.now();
                    0 < diff && (newTimeout = self.cronTime.getTimeout(), remaining += newTimeout = diff < newTimeout ? diff : newTimeout), self.lastExecution = new Date(), remaining ? (MAXDELAY < remaining ? (remaining -= MAXDELAY, timeout = MAXDELAY) : (timeout = remaining, remaining = 0), _setTimeout(timeout)) : (self.running = !1, self.runOnce || self.start(), self.fireOnTick());
                }
                this.running || (MAXDELAY = 2147483647, timeout = (self = this).cronTime.getTimeout(), remaining = 0, this.cronTime.realDate && (this.runOnce = !0), 0 <= timeout ? (this.running = !0, MAXDELAY < timeout && (remaining = timeout - MAXDELAY, timeout = MAXDELAY), _setTimeout(timeout)) : this.stop());
            });
            return CJ.prototype.start = start, CJ.prototype.lastDate = function() {
                return this.lastExecution;
            }, CJ.prototype.stop = function() {
                this._timeout && clearTimeout(this._timeout), this.running = !1, "function" == typeof this.onComplete && this.onComplete();
            }, CJ;
        };
    }), _$CronTime_5 = createModuleFactory(function(module, exports) {
        const CONSTRAINTS = [ [ 0, 59 ], [ 0, 59 ], [ 0, 23 ], [ 1, 31 ], [ 0, 11 ], [ 0, 6 ] ], MONTH_CONSTRAINTS = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ], PARSE_DEFAULTS = [ "0", "*", "*", "*", "*", "*" ], ALIASES = {
            jan: 0,
            feb: 1,
            mar: 2,
            apr: 3,
            may: 4,
            jun: 5,
            jul: 6,
            aug: 7,
            sep: 8,
            oct: 9,
            nov: 10,
            dec: 11,
            sun: 0,
            mon: 1,
            tue: 2,
            wed: 3,
            thu: 4,
            fri: 5,
            sat: 6
        }, TIME_UNITS = [ "second", "minute", "hour", "dayOfMonth", "month", "dayOfWeek" ], TIME_UNITS_LEN = TIME_UNITS.length, PRESETS = {
            "@yearly": "0 0 0 1 0 *",
            "@monthly": "0 0 0 1 * *",
            "@weekly": "0 0 0 * * 0",
            "@daily": "0 0 0 * * *",
            "@hourly": "0 0 * * * *",
            "@minutely": "0 * * * * *",
            "@secondly": "* * * * * *",
            "@weekdays": "0 0 0 * * 1-5",
            "@weekends": "0 0 0 * * 0,6"
        }, RE_WILDCARDS = /\*/g, RE_RANGE = /^(\d+)(?:-(\d+))?(?:\/(\d+))?$/g;
        module.exports = function(luxon) {
            function CT(source, zone, utcOffset) {
                if (this.source = source, zone) {
                    if (luxon.DateTime.fromObject({}, {
                        zone: zone
                    }).invalid) throw new Error("Invalid timezone.");
                    this.zone = zone;
                }
                void 0 !== utcOffset && (this.utcOffset = utcOffset);
                var that = this;
                TIME_UNITS.map(timeUnit => {
                    that[timeUnit] = {};
                }), this.source instanceof Date || this.source instanceof luxon.DateTime ? (this.source instanceof Date && (this.source = luxon.DateTime.fromJSDate(this.source)), this.realDate = !0) : (this._parse(this.source), this._verifyParse());
            }
            return CT.prototype = {
                _verifyParse: function() {
                    for (var months = Object.keys(this.month), dom = Object.keys(this.dayOfMonth), ok = !1, lastWrongMonth = NaN, i = 0; i < months.length; i++) {
                        for (var m = months[i], con = MONTH_CONSTRAINTS[parseInt(m, 10)], j = 0; j < dom.length; j++) dom[j] <= con && (ok = !0);
                        ok || (lastWrongMonth = m, console.warn(`Month '${m}' is limited to '${con}' days.`));
                    }
                    if (!ok) for (var notOkCon = MONTH_CONSTRAINTS[parseInt(lastWrongMonth, 10)], k = 0; k < dom.length; k++) {
                        var notOkDay = dom[k];
                        notOkCon < notOkDay && (delete this.dayOfMonth[notOkDay], notOkDay = Number(notOkDay) % notOkCon, this.dayOfMonth[notOkDay] = !0);
                    }
                },
                sendAt: function(i) {
                    var date = this.realDate ? this.source : luxon.DateTime.local();
                    if (this.zone && (date = date.setZone(this.zone)), void 0 !== this.utcOffset) {
                        var offset = 60 <= this.utcOffset || this.utcOffset <= -60 ? this.utcOffset / 60 : this.utcOffset;
                        let utcZone = "UTC";
                        if ((offset = parseInt(offset)) < 0 ? utcZone += offset : 0 < offset && (utcZone += "+" + offset), (date = date.setZone(utcZone)).invalid) throw new Error("ERROR: You specified an invalid UTC offset.");
                    }
                    if (this.realDate) {
                        if (luxon.DateTime.local() > date) throw new Error("WARNING: Date in past. Will never be fired.");
                        return date;
                    }
                    if (isNaN(i) || i < 0) return this._getNextDateFrom(date);
                    for (var dates = []; 0 < i; i--) date = this._getNextDateFrom(date), dates.push(date);
                    return dates;
                },
                getTimeout: function() {
                    return Math.max(-1, this.sendAt() - luxon.DateTime.local());
                },
                toString: function() {
                    return this.toJSON().join(" ");
                },
                toJSON: function() {
                    var self = this;
                    return TIME_UNITS.map(function(timeName) {
                        return self._wcOrAll(timeName);
                    });
                },
                _getNextDateFrom: function(start, zone) {
                    var date = start = start instanceof Date ? luxon.DateTime.fromJSDate(start) : start, firstDate = start.toMillis();
                    if (zone && (date = date.setZone(zone)), this.realDate || 0 < date.millisecond && (date = date.set({
                        millisecond: 0,
                        second: date.second + 1
                    })), date.invalid) throw new Error("ERROR: You specified an invalid date.");
                    for (var timeout = Date.now() + 5e3; ;) {
                        var diff = date - start;
                        if (Date.now() > timeout) throw new Error(`Something went wrong. It took over five seconds to find the next execution time for the cron job.
							Please refer to the canonical issue (https://github.com/kelektiv/node-cron/issues/467) and provide the following string if you would like to help debug:
							Time Zone: ${zone || '""'} - Cron String: ${this} - UTC offset: ${date.format("Z")} - current Date: ` + luxon.DateTime.local().toString());
                        if (date.month - 1 in this.month || 12 === Object.keys(this.month).length) if (date.day in this.dayOfMonth || 31 === Object.keys(this.dayOfMonth).length || date.getWeekDay() in this.dayOfWeek && 7 !== Object.keys(this.dayOfWeek).length) if (date.getWeekDay() in this.dayOfWeek || 7 === Object.keys(this.dayOfWeek).length || date.day in this.dayOfMonth && 31 !== Object.keys(this.dayOfMonth).length) if (date.hour in this.hour || 24 === Object.keys(this.hour).length) if (date.minute in this.minute || 60 === Object.keys(this.minute).length) if (date.second in this.second || 60 === Object.keys(this.second).length) {
                            if (date.toMillis() !== firstDate) break;
                            date = date.set({
                                second: date.second + 1
                            });
                        } else date = date.set({
                            second: 59 === date.second && 6e4 < diff ? 0 : date.second + 1
                        }); else date = (date = date.set({
                            minute: 59 === date.minute && 36e5 < diff ? 0 : date.minute + 1
                        })).set({
                            second: 0
                        }); else date = (date = date.set({
                            hour: 23 === date.hour && 864e5 < diff ? 0 : date.hour + 1
                        })).set({
                            minute: 0,
                            second: 0
                        }); else date = (date = date.plus({
                            days: 1
                        })).set({
                            hour: 0,
                            minute: 0,
                            second: 0
                        }); else date = (date = date.plus({
                            days: 1
                        })).set({
                            hour: 0,
                            minute: 0,
                            second: 0
                        }); else date = (date = date.plus({
                            months: 1
                        })).set({
                            day: 1,
                            hour: 0,
                            minute: 0,
                            second: 0
                        });
                    }
                    return date;
                },
                _wcOrAll: function(type) {
                    if (this._hasAll(type)) return "*";
                    var time, all = [];
                    for (time in this[type]) all.push(time);
                    return all.join(",");
                },
                _hasAll: function(type) {
                    for (var constraints = CONSTRAINTS[TIME_UNITS.indexOf(type)], i = constraints[0], n = constraints[1]; i < n; i++) if (!(i in this[type])) return !1;
                    return !0;
                },
                _parse: function(source) {
                    var units = (source = (source = (source = source.toLowerCase()) in PRESETS ? PRESETS[source] : source).replace(/[a-z]{1,3}/gi, alias => {
                        if (alias in ALIASES) return ALIASES[alias];
                        throw new Error("Unknown alias: " + alias);
                    })).trim().split(/\s+/);
                    if (units.length < TIME_UNITS_LEN - 1) throw new Error("Too few fields");
                    if (units.length > TIME_UNITS_LEN) throw new Error("Too many fields");
                    for (var unitsLen = units.length, i = 0; i < TIME_UNITS_LEN; i++) {
                        var cur = units[i - (TIME_UNITS_LEN - unitsLen)] || PARSE_DEFAULTS[i];
                        this._parseField(cur, TIME_UNITS[i], CONSTRAINTS[i]);
                    }
                },
                _parseField: function(value, type, constraints) {
                    for (var pointer, typeObj = this[type], low = constraints[0], high = constraints[1], allRanges = (value.split(",").forEach(field => {
                        var wildcardIndex = field.indexOf("*");
                        if (-1 !== wildcardIndex && 0 !== wildcardIndex) throw new Error(`Field (${field}) has an invalid wildcard expression`);
                    }), (value = value.replace(RE_WILDCARDS, low + "-" + high)).split(",")), i = 0; i < allRanges.length; i++) {
                        if (!allRanges[i].match(RE_RANGE)) throw new Error(`Field (${type}) cannot be parsed`);
                        allRanges[i].replace(RE_RANGE, ($0, lower, upper, step) => {
                            lower = parseInt(lower, 10), upper = parseInt(upper, 10) || void 0;
                            var wasStepDefined = !isNaN(parseInt(step, 10));
                            if ("0" === step) throw new Error(`Field (${type}) has a step of zero`);
                            if (step = parseInt(step, 10) || 1, upper && upper < lower) throw new Error(`Field (${type}) has an invalid range`);
                            if (lower < low || upper && high < upper || !upper && high < lower) throw new Error(`Field value (${value}) is out of range`);
                            for (lower = Math.min(Math.max(low, ~~Math.abs(lower)), high), upper = upper ? Math.min(high, ~~Math.abs(upper)) : wasStepDefined ? high : lower, pointer = lower; typeObj[pointer] = !0, (pointer += step) <= upper; );
                        });
                    }
                }
            }, CT;
        };
    }), _$_empty_2 = createModuleFactory(function(module, exports) {}), _$cron_3 = {};
    root = this, factory = function(luxon, childProcess) {
        var exports = {}, childProcess = childProcess && childProcess.spawn;
        const CronTime = _$CronTime_5({})(luxon), CronJob = _$CronJob_4({})(CronTime, childProcess);
        return luxon.DateTime.prototype.getWeekDay = function() {
            return 7 === this.weekday ? 0 : this.weekday;
        }, exports.job = (cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) => new CronJob(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout), exports.time = (cronTime, timeZone) => new CronTime(cronTime, timeZone), exports.sendAt = cronTime => exports.time(cronTime).sendAt(), exports.timeout = cronTime => exports.time(cronTime).getTimeout(), exports.CronJob = CronJob, exports.CronTime = CronTime, exports;
    }, "function" == typeof define && define.amd ? define([ "luxon" ], factory) : "object" == typeof _$cron_3 ? _$cron_3 = factory(require(6), _$_empty_2({})) : root.Cron = factory(root.luxon);
    !function(global) {
        !function() {
            "use strict";
            var obj = (obj = _$cron_3) && obj.__esModule ? obj : {
                default: obj
            };
            global.Cron = obj.default;
        }.call(this);
    }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}();
